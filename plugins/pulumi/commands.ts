/*
 * Copyright (C) 2018-2022 Garden Technologies, Inc. <info@garden.io>
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

import chalk from "chalk"
import { ConfigGraph, Garden, GardenService, LogEntry, PluginTask } from "@garden-io/sdk/types"
import { PluginCommand, PluginCommandParams } from "@garden-io/sdk/types"

import { PulumiModule, PulumiProvider } from "./config"
import { Profile } from "@garden-io/core/build/src/util/profiling"
import { cancelUpdate, getPreviewDirPath, getStackStatus, PulumiParams, refreshResources, reimportStack } from "./helpers"
import { dedent } from "@garden-io/sdk/util/string"
import { emptyDir } from "fs-extra"

type PulumiRunFn = (params: PulumiParams) => Promise<void>

interface PulumiCommandSpec {
  name: string
  commandDescription: string
  beforeFn?: ({ ctx: PluginContext, log: LogEntry }) => Promise<void>
  runFn: PulumiRunFn
}

const pulumiCommandSpecs: PulumiCommandSpec[] = [
  {
    name: "preview",
    commandDescription: "pululumi preview",
    beforeFn: async ({ ctx, log }) => {
      const previewDirPath = getPreviewDirPath(ctx)
      // We clear the preview dir, so that it contains only the plans generated by this preview command.
      log.info(`Clearing preview dir at ${previewDirPath}...`)
      await emptyDir(previewDirPath)
    },
    runFn: async (params) => {
      const { ctx, log } = params
      const previewDirPath = getPreviewDirPath(ctx)
      await getStackStatus({ ...params, logPreview: true, previewDirPath })
    }
  },
  {
    name: "cancel",
    commandDescription: "pululumi cancel",
    runFn: async (params) => await cancelUpdate(params)
  },
  {
    name: "refresh",
    commandDescription: "pululumi refresh",
    runFn: async (params) => await refreshResources(params)
  },
  {
    name: "reimport",
    commandDescription: "pululumi export | pulumi import",
    runFn: async (params) => await reimportStack(params)
  },
]

interface PulumiPluginCommandTaskParams {
  garden: Garden
  graph: ConfigGraph
  log: LogEntry
  service: GardenService
  commandName: string
  commandDescription: string
  runFn: PulumiRunFn
  pulumiParams: PulumiParams
}

@Profile()
class PulumiPluginCommandTask extends PluginTask {
  graph: ConfigGraph
  pulumiParams: PulumiParams
  service: GardenService
  commandName: string
  commandDescription: string
  runFn: PulumiRunFn

  constructor({
    garden,
    graph,
    log,
    service,
    commandName,
    commandDescription,
    runFn,
    pulumiParams
  }: PulumiPluginCommandTaskParams) {
    super({ garden, log, force: false, version: service.version })
    this.graph = graph
    this.service = service
    this.commandName = commandName
    this.commandDescription = commandDescription
    this.runFn = runFn
    this.pulumiParams = pulumiParams
    const provider = <PulumiProvider>pulumiParams.ctx.provider
    this.concurrencyLimit = provider.config.pluginTaskConcurrencyLimit
  }

  getName() {
    return this.service.name
  }

  getDescription(): string {
    return `running ${chalk.white(this.commandName)} for ${this.service.name}`
  }

  async resolveDependencies(): Promise<PluginTask[]> {
    const pulumiServiceNames = this.graph.getModules()
      .filter((m) => m.type === "pulumi")
      .map((m) => m.name) // module names are the same as service names for pulumi modules
    const deps = this.graph.getDependencies({
      nodeType: "deploy",
      name: this.getName(),
      recursive: false,
      filter: (depNode) => pulumiServiceNames.includes(depNode.name)
    })
    return deps.deploy.map((depService) => {
      return new PulumiPluginCommandTask({
        garden: this.garden,
        graph: this.graph,
        log: this.log,
        service: depService,
        commandName: this.commandName,
        commandDescription: this.commandDescription,
        runFn: this.runFn,
        pulumiParams: { ...this.pulumiParams, module: depService.module },
      })
    })
  }

  async process(): Promise<{}> {
    const log = this.log.info({
      section: this.getName(),
      msg: chalk.gray(`Running ${chalk.white(this.commandDescription)}`),
      status: "active",
    })
    try {
      await this.runFn(this.pulumiParams)
    } catch (err) {
      log.setError({
        msg: chalk.red(`Failed! (took ${log.getDuration(1)} sec)`),
      })
      throw err
    }
    log.setSuccess({
      msg: chalk.green(`Success (took ${log.getDuration(1)} sec)`),
    })
    return {}
  }
}

export const getPulumiCommands = (): PluginCommand[] =>
  pulumiCommandSpecs.map(makePulumiCommand)

function makePulumiCommand({ name, commandDescription, beforeFn, runFn }: PulumiCommandSpec) {
  const description = commandDescription || `pulumi ${name}`
  const pulumiCommand = chalk.bold(description)

  return {
    name,
    description: dedent`
      Runs ${pulumiCommand} for the specified pulumi services, in dependency order (or for all pulumi services if no
      service names are provided).
    `,
    // We don't want to call `garden.getConfigGraph` twice (we need to do it in the handler anyway)
    resolveModules: false,

    title: ({ args }) =>
      chalk.bold.magenta(`Running ${chalk.white.bold(pulumiCommand)} for module ${chalk.white.bold(args[0] || "")}`),


    async handler({ garden, ctx, args, log }: PluginCommandParams) {
      const serviceNames = args.length === 0 ? undefined : args
      const graph = await garden.getConfigGraph({ log, emit: false })

      if (beforeFn) {
        await beforeFn({ ctx, log })
      }

      const provider = ctx.provider as PulumiProvider
      const services = graph.getServices({ names: serviceNames }).filter((s) => s.module.type === "pulumi")

      const tasks = services.map((service) => {
        const pulumiParams: PulumiParams = {
          ctx,
          provider,
          log,
          module: <PulumiModule>service.module,
        }
        return new PulumiPluginCommandTask({
          garden,
          graph,
          log,
          service,
          commandName: name,
          commandDescription,
          runFn: runFn,
          pulumiParams,
        })
      })

      await garden.processTasks(tasks)

      return { result: {} }
    },
  }
}
